-- IMPORTANDO TEXTURAS -- global Ttronco=sysInfo.currentdir+"\\Texturas\\tronco.jpg"meditMaterials[4].diffuseMap=BitmapTexture filename:TtroncomeditMaterials[4].showInViewport=onttroncorect=uvwmap()ttroncorect.maptype=2;ttroncocil=uvwmap()ttroncocil.maptype=2;global Tarbol=sysInfo.currentdir+"\\Texturas\\arbolin.jpg"meditMaterials[5].diffuseMap=BitmapTexture filename:TarbolmeditMaterials[5].showInViewport=ontcopa=uvwmap()tcopa.maptype=4;			global Tboladorada=sysInfo.currentdir+"\\Texturas\\boladorada.jpg"meditMaterials[6].diffuseMap=BitmapTexture filename:TboladoradameditMaterials[6].showInViewport=ontbroja=uvwmap()tbroja.maptype=3;global Tbolaroja=sysInfo.currentdir+"\\Texturas\\bolaroja.jpg"meditMaterials[7].diffuseMap=BitmapTexture filename:TbolarojameditMaterials[7].showInViewport=ontbdorada=uvwmap()tbdorada.maptype=3;		global Tbolaplateada=sysInfo.currentdir+"\\Texturas\\bolaplateada.jpg"meditMaterials[8].diffuseMap=BitmapTexture filename:TbolaplateadameditMaterials[8].showInViewport=onglobal Tbolaazul=sysInfo.currentdir+"\\Texturas\\bolaazul.jpg"meditMaterials[9].diffuseMap=BitmapTexture filename:TbolaazulmeditMaterials[9].showInViewport=onglobal Tregalo1=sysInfo.currentdir+"\\Texturas\\regalo1.jpg"meditMaterials[10].diffuseMap=BitmapTexture filename:Tregalo1meditMaterials[10].showInViewport=onglobal Tregalo2=sysInfo.currentdir+"\\Texturas\\regalo2.jpg"meditMaterials[11].diffuseMap=BitmapTexture filename:Tregalo2meditMaterials[11].showInViewport=onglobal Tregalo3=sysInfo.currentdir+"\\Texturas\\regalo3.png"meditMaterials[12].diffuseMap=BitmapTexture filename:Tregalo3meditMaterials[12].showInViewport=onglobal Tregalo4=sysInfo.currentdir+"\\Texturas\\regalo4.jpg"meditMaterials[13].diffuseMap=BitmapTexture filename:Tregalo4meditMaterials[13].showInViewport=onglobal Tregalo5=sysInfo.currentdir+"\\Texturas\\regalo5.jpg"meditMaterials[14].diffuseMap=BitmapTexture filename:Tregalo5meditMaterials[14].showInViewport=on-- VARIABLES GLOBALES ---- variables especiales para el randomizador --		global ancho;		global alto;		global alturacopa;		global anchcopa;global arbolX=0;global arbolY=0;global arbolZ=0;global creado=false;global anchoTro=2;global altoTro=10;global rectangon=false;global cilindon=false;global radioCopa=6;global altuCopa=40;global layers=1; global radioBola=0;global numeroBolas=0;global vectorBolas =#()global radio1star=0;global radio2star=0;global puntas=0;global luministar=0;global nLuz=0;global nEsp=0;-- control colocacion de objetos --global recopiladorpos=#();global randomizando=false;--materiales y colores--global matTronco=undefined;global colorTronco=(color 153 153 129);global coloresAleatoriosTro=false;global matCopa=undefined;global colorCo=(color 153 153 129);global coloresAleatoriosCopa=false;global matBola=undefined;global colorBo=(color 153 153 129);global coloresAleatoriosBola=false;global matStar=undefined;global colorEstre=(color 153 153 129)global coloresAleatoriosStar=false;global colorLight=(color 153 153 129)global luminiscencia=0;global coloresAleatoriosLuz=false;global prematerialtronco=true;global prematerialcopa=true;global prematerialbola=true;global texturaescogida=false;--FUNCIONES--fn crearTroncoRect posicionX posicionY posicionZ=	(	tronco1=box  length:anchoTro width:anchoTro height:altoTro position: [posicionX, posicionY, posicionZ] 					if(prematerialtronco==false) then(		if(texturaescogida==false)then(		if coloresAleatorios == true then			(					re = random 0 255				gr = random 0 255				bl = random 0 255				tronco1.wirecolor = (color re gr bl)			)		else			(							tronco1.wirecolor=colorTronco;			)		)		else(						tronco1.material=matTronco;						)		)		else(						tronco1.material=(meditMaterials[4])							addModifier tronco1 ttroncorect;						)			misonido=NoiseModifier seed: 1 scale:100.0 fractal:true roughness: 0.875 iterations: 9.87 strength:[1.18,1.92,-0.047]		addModifier tronco1  misonido;	prematerialtronco=true;	texturaescogida=true;) fn crearTroncoCil posicionX posicionY posicionZ =	(	tronco2 = cylinder radius:anchoTro height:altoTro position: [posicionX, posicionY, posicionZ] 				if(prematerialtronco==false)then(		if(texturaescogida==false)then(		if coloresAleatoriosTro == true then			(					re = random 0 255				gr = random 0 255				bl = random 0 255				tronco2.wirecolor = (color re gr bl)			)		else			tronco2.wirecolor=colorTronco;					)	else(				tronco2.material= matTronco;				)	)		else(			tronco2.material= (meditMaterials[4])			addModifier tronco2 ttroncocil;						)			misonido=NoiseModifier seed: 1 scale:100.0 fractal:true roughness: 0.875 iterations: 9.87 strength:[1.18,1.92,-0.047]		addModifier tronco2  misonido;			prematerialcopa=true;					texturaescogida=true;			)fn crearCopa posicionX posicionY posicionZ =(	/*posicionZ=posicionZ + altoTro;*/	/*tuCopa1=altuCopa-4;	altuCopa2=altuCopa-1;*/	posicionZ=posicionZ + altoTro; --aqui lo que conseguimos es que aparezca justo encima de la altura del tronco--	copa= cone radius1:radioCopa  height:altuCopa   position:[posicionX, posicionY, posicionZ] 					if(prematerialcopa==false)then(		if(texturaescogida==false)then(		if coloresAleatoriosTro == true then			(					re = random 0 255				gr = random 0 255				bl = random 0 255				copa.wirecolor = (color re gr bl)			)		else			copa.wirecolor=colorCo;					)	else(				copa.material= matCopa;				)	)		else(			copa.material= (meditMaterials[5])			addModifier copa tcopa;						)						misonido=NoiseModifier seed:0 scale:100.0 fractal:true roughness:1.0 iterations:10.0  strength:[-0.251,0.52,0]		addModifier copa  misonido;	addModifier copa tcopa;						prematerialcopa=true;			texturaescogida=true;				)fn creandoBolas cantidad radio=( 		if(randomizando==true) then(						contador=0;	while(contador<cantidad) do	(	a=random 0 360;	b=random 0.1 0.9;		-- definimos el punto de la punta--		x1= arbolX;	y1 = arbolY;	z1 = arbolZ + alturacopa+ alto;		-- definimos el punto del extremo del cono del árbol--		x2=arbolX+ (cos(a)*(anchcopa));	y2=arbolY+ (sin(a)*(anchcopa));	z2=arbolZ + alto;			-- dfvc--		xi=x1+(b*(x2-x1));		yi=y1+(b*(y2-y1));			zi=z1+(b*(z2-z1));				    xi=(floor((10*xi)+0.5)/10)	yi=(floor((10*yi)+0.5)/10)	zi=(floor((10*zi)+0.5)/10)				--AQUÍ COMIENZA EL CONTROL DE LA SUPERPOSICIÓN-- 	vectorposfinal=[xi,yi,zi];	-- gestionamos que se pueda colocar y que esa posición no esté ocupada --			booolean1=findItem recopiladorpos vectorposfinal; --devuelve cero si no está en el array esa posición exacta--		xaux=xi;		yaux=yi;		zaux=zi;		verdad=true;		if(booolean1 ==0) then( --ojo, pero hay que gestionar que no estén posiciones cercanas al radio de la bola-- 						--ahora estamos probando la equis			nxmin=xaux-(radio*2);			nxmax=xaux+(radio*2);			nymin=yaux-(radio*2);			nymax=yaux+(radio*2);			nzmin=zaux-(radio*2);			nzmax=zaux+(radio*2);					np=recopiladorpos.count;			for n=1 to np do(				if(verdad==true) then(					if(xaux>=(recopiladorpos[n][1]-(radio*2)) and xaux<=(recopiladorpos[n][1]+(radio*2)) and yaux>=(recopiladorpos[n][2]-(radio*2)) and yaux<=(recopiladorpos[n][2]+(radio*2)) and zaux>=(recopiladorpos[n][3]-(radio*2)) and zaux<=(recopiladorpos[n][3]+(radio*2))) then(						verdad=false;											)				)			)																			if(verdad==true) then(			        					bola= sphere radius:radio position:[xi,yi,zi] 								if(contador>=0 and contador<=5) then( --roja									bola.material=(meditMaterials[6]); 								)								if(contador>5 and contador <=10) then( --dorada									bola.material=(meditMaterials[7]);								)								if(contador>10 and contador<=15) then( --plateada--									bola.material=(meditMaterials[8]);								)																if(contador>15 and contador<=20) then ( --azul									bola.material=(meditMaterials[9]);									)								if(contador>20 and contador<=25) then( --roja									bola.material=(meditMaterials[6]); 								)								if(contador>25 and contador <=30) then( --dorada									bola.material=(meditMaterials[7]);								)								if(contador>30 and contador<=35) then( --plateada--									bola.material=(meditMaterials[8]);								)																if(contador>35 and contador<=40) then ( --azul									bola.material=(meditMaterials[9]);									)																															addModifier bola tbroja;					append recopiladorpos [xi,yi,zi];					contador=contador+1;				)						-- ahora habrá que gestionar los radios --		)	))	else(										contador=0;	while(contador<cantidad) do	(	a=random 0 360;	b=random 0.1 0.9;		-- definimos el punto de la punta--		x1= arbolX;	y1 = arbolY;	z1 = arbolZ + altuCopa+ altoTro;		-- definimos el punto del extremo del cono del árbol--		x2=arbolX+ (cos(a)*(radioCopa));	y2=arbolY+ (sin(a)*(radioCopa));	z2=arbolZ + altoTro;			-- puntos de la recta entre la punta y el extremo--		xi=x1+(b*(x2-x1));		yi=y1+(b*(y2-y1));			zi=z1+(b*(z2-z1));				    xi=(floor((10*xi)+0.5)/10)	yi=(floor((10*yi)+0.5)/10)	zi=(floor((10*zi)+0.5)/10)				--AQUÍ COMIENZA EL CONTROL DE LA SUPERPOSICIÓN-- 	vectorposfinal=[xi,yi,zi];	-- gestionamos que se pueda colocar y que esa posición no esté ocupada --			booolean1=findItem recopiladorpos vectorposfinal; --devuelve cero si no está en el array esa posición exacta--		xaux=xi;		yaux=yi;		zaux=zi;		verdad=true;		if(booolean1 ==0) then( 				nxmin=xaux-(radio*2); 			nxmax=xaux+(radio*2);			nymin=yaux-(radio*2);			nymax=yaux+(radio*2);			nzmin=zaux-(radio*2);			nzmax=zaux+(radio*2);					np=recopiladorpos.count;			for n=1 to np do(				if(verdad==true) then(					if(xaux>=(recopiladorpos[n][1]-(radio*2)) and xaux<=(recopiladorpos[n][1]+(radio*2)) and						yaux>=(recopiladorpos[n][2]-(radio*2)) and yaux<=(recopiladorpos[n][2]+(radio*2)) and 							zaux>=(recopiladorpos[n][3]-(radio*2)) and zaux<=(recopiladorpos[n][3]+(radio*2))) then(						verdad=false;											)				)			)																			if(verdad==true) then(																									        					bola= sphere radius:radio position:[xi,yi,zi] 											--- aqui controlo tema de texturas, o si ha escogido un color, o si quiere la textura de por defecto--																						if(prematerialbola==true)then(																														if(contador>=0 and contador<=5) then( --roja									bola.material=(meditMaterials[6]); 								)								if(contador>5 and contador <=10) then( --dorada									bola.material=(meditMaterials[7]);								)								if(contador>10 and contador<=15) then( --plateada--									bola.material=(meditMaterials[8]);								)																if(contador>15 and contador<=20) then ( --azul									bola.material=(meditMaterials[9]);									)								if(contador>20 and contador<=25) then( --roja									bola.material=(meditMaterials[6]); 								)								if(contador>25 and contador <=30) then( --dorada									bola.material=(meditMaterials[7]);								)								if(contador>30 and contador<=35) then( --plateada--									bola.material=(meditMaterials[8]);								)																if(contador>35 and contador<=40) then ( --azul									bola.material=(meditMaterials[9]);									)																															addModifier bola tbroja;																										)								else(											if(texturaescogida==false)then(								if coloresAleatoriosBola == true then			(					re = random 0 255				gr = random 0 255				bl = random 0 255			    bola.wirecolor = (color re gr bl)			)		else (				bola.wirecolor=colorBo;		)		)	else(				bola.material= matBola;				)											)																																																																														append recopiladorpos [xi,yi,zi];					contador=contador+1;				)						-- ahora habrá que gestionar los radios --		)							)		prematerialbola=true;		texturaescogida=true;	))						fn creandoEstrella rad1 rad2 picos luminiscencia =(						extrudeision=extrude amount:1			estrella= Star radius1: rad1 radius2:rad2 position:[arbolX,arbolY,arbolZ+altoTro+altuCopa];			estrella.baseobject.points=picos;			      						if( coloresAleatoriosStar ==true) then(						mat =architectural();						mat.diffuseColor=( color (random 0 255) (random 0 255) (random 0 255));						mat.luminance= luminiscencia;						mat.showInViewport= true;						estrella.material=mat;					)					else(							mat =architectural();					mat.diffuseColor= colorEstre;					mat.luminance= luminiscencia;					mat.showInViewport= true;					estrella.material=mat;							)			addModifier estrella extrudeision; --habrá que indicar valores predeterminados al usuario de los que quedan bien para formar la estrella, por ejemplo: 0.7 radio1 2 radio2						rot_star= eulerangles 0 90 0;			rotate estrella rot_star		)			fn creandoLuces numeroLuces luminis =(	if(randomizando==true) then(		contador=0;	while(contador<numeroLuces) do	(	a=random 0 360;	b=random 0.2 0.9;		-- definimos el punto de la punta--		x1= arbolX;	y1 = arbolY;	z1 = arbolZ + alturacopa+ alto;		-- definimos el punto del extremo del cono del árbol--		x2=arbolX+ (cos(a)*(anchcopa));	y2=arbolY+ (sin(a)*(anchcopa));	z2=arbolZ + alto;			-- dfvc--		xi=x1+(b*(x2-x1));		yi=y1+(b*(y2-y1));			zi=z1+(b*(z2-z1));				    xi=(floor((10*xi)+0.5)/10)	yi=(floor((10*yi)+0.5)/10)	zi=(floor((10*zi)+0.5)/10)				--AQUÍ COMIENZA EL CONTROL DE LA SUPERPOSICIÓN-- 	vectorposfinal=[xi,yi,zi];	-- gestionamos que se pueda colocar y que esa posición no esté ocupada --			booolean1=findItem recopiladorpos vectorposfinal; --devuelve cero si no está en el array esa posición exacta--		xaux=xi;		yaux=yi;		zaux=zi;		verdad=true;		--ojo, pero hay que gestionar que no estén posiciones cercanas al radio de la bola-- 						--ahora estamos probando la equis			nxmin=xaux-(1);			nxmax=xaux+(1);			nymin=yaux-(1);			nymax=yaux+(1);			nzmin=zaux-(2);			nzmax=zaux+(2);			np=recopiladorpos.count;			for n=1 to np do(				if(verdad==true) then(					if(xaux>=(recopiladorpos[n][1]-(1)) and xaux<=(recopiladorpos[n][1]+(1)) and yaux>=(recopiladorpos[n][2]-(1)) and yaux<=(recopiladorpos[n][2]+(1)) and zaux>=(recopiladorpos[n][3]-(2)) and zaux<=(recopiladorpos[n][3]+(2))) then(						verdad=false;											)				)			)																			if(verdad==true) then(			        					bombilla= spindle radius:0.5 height:2 Cap_Height:0.5 position:[xi,yi,zi];					      												mat =architectural();						mat.diffuseColor=( color (random 0 255) (random 0 255) (random 0 255));						mat.luminance= luminis;						mat.showInViewport= true;						bombilla.material=mat;																append recopiladorpos [xi,yi,zi];					contador=contador+1;				)					-- ahora habrá que gestionar los radios --		)				)		else(		contador=0;	while(contador<numeroLuces) do	(	a=random 0 360;	b=random 0.2 0.9;		-- definimos el punto de la punta--		x1= arbolX;	y1 = arbolY;	z1 = arbolZ + altuCopa+ altoTro;		-- definimos el punto del extremo del cono del árbol--		x2=arbolX+ (cos(a)*(radioCopa));	y2=arbolY+ (sin(a)*(radioCopa));	z2=arbolZ + altoTro;			-- dfvc--		xi=x1+(b*(x2-x1));		yi=y1+(b*(y2-y1));			zi=z1+(b*(z2-z1));				    xi=(floor((10*xi)+0.5)/10)	yi=(floor((10*yi)+0.5)/10)	zi=(floor((10*zi)+0.5)/10)				--AQUÍ COMIENZA EL CONTROL DE LA SUPERPOSICIÓN-- 	vectorposfinal=[xi,yi,zi];	-- gestionamos que se pueda colocar y que esa posición no esté ocupada --			booolean1=findItem recopiladorpos vectorposfinal; --devuelve cero si no está en el array esa posición exacta--		xaux=xi;		yaux=yi;		zaux=zi;		verdad=true;		--ojo, pero hay que gestionar que no estén posiciones cercanas al radio de la bola-- 						--ahora estamos probando la equis			nxmin=xaux-(1);			nxmax=xaux+(1);			nymin=yaux-(1);			nymax=yaux+(1);			nzmin=zaux-(2);			nzmax=zaux+(2);			np=recopiladorpos.count;			for n=1 to np do(				if(verdad==true) then(					if(xaux>=(recopiladorpos[n][1]-(1)) and xaux<=(recopiladorpos[n][1]+(1)) and yaux>=(recopiladorpos[n][2]-(1)) and yaux<=(recopiladorpos[n][2]+(1)) and zaux>=(recopiladorpos[n][3]-(2)) and zaux<=(recopiladorpos[n][3]+(2))) then(						verdad=false;											)				)			)																			if(verdad==true) then(			        					bombilla= spindle radius:0.5 height:2 Cap_Height:0.5 position:[xi,yi,zi];					      						if( coloresAleatoriosLuz ==true) then(						mat =architectural();						mat.diffuseColor=( color (random 0 255) (random 0 255) (random 0 255));						mat.luminance= luminis;						mat.showInViewport= true;						bombilla.material=mat;					)					else(							mat =architectural();					mat.diffuseColor= colorLight;					mat.luminance= luminis;					mat.showInViewport= true;					bombilla.material=mat;							)					append recopiladorpos [xi,yi,zi];					contador=contador+1;				)					-- ahora habrá que gestionar los radios --		)				))				fn creandoRegalos cantidad =(		posicionx=arbolX+radioCopa;	topex=arbolX+radioCopa+4;	posiciony=arbolY;	topey=arbolY+radioCopa+4;	posicionz=arbolZ;		cont=0;		for i=1 to cantidad do(				alt= random 1 altoTro;		anch= random 1 altoTro;		prof= random 1 altoTro;				posx= random posicionx topex;		posy= random posiciony topey;		posicionz=arbolZ;				regalo= box  length:prof width:anch height:alt position:[posx , posy , posicionz];			if(cont>=0 and cont<5) then(		regalo.material= (meditMaterials[10]);	)	if(cont>=5 and cont<10) then(		regalo.material= (meditMaterials[11]);	)	if(cont>=10 and cont<15) then(		regalo.material= (meditMaterials[12]);	)	if(cont>=15 and cont<20) then(		regalo.material= (meditMaterials[13]);	)		if(cont>=20 and cont<=25) then(		regalo.material= (meditMaterials[14]);	)			addModifier regalo tcopa;				cont=cont+1;				))		fn creandoArbolCualquiera =(		randomizando=true;			  valor= random 0 1 	if(valor==0) then(				ancho= random 1 4;		alto = random 2 6;		tronco1=box  length:ancho width:ancho height:alto position: [arbolX, arbolY, arbolZ] material:(meditMaterials[4])					misonido=NoiseModifier seed: 1 scale:100.0 fractal:true roughness: 0.875 iterations: 9.87 strength:[1.18,1.92,-0.047]		addModifier tronco1 misonido;	addModifier tronco1 ttroncocil;			)	else(				ancho= random 1 4;		alto= random 2 6;						tronco2 = cylinder radius:ancho height:alto position: [arbolX, arbolY, arbolZ] material: (meditMaterials[4])					misonido=NoiseModifier seed: 1 scale:100.0 fractal:true roughness: 0.875 iterations: 9.87 strength:[1.18,1.92,-0.047]		addModifier tronco2  misonido;	addModifier tronco2 ttroncocil;				)						posicionZ=arbolZ + alto; --aqui lo que conseguimos es que aparezca justo encima de la altura del tronco--	alturacopa= random 10 40;	anchcopa= random 5 10;	copa= cone radius1:anchcopa  height:alturacopa   position:[arbolX, arbolY, posicionZ] material: (meditMaterials[5])	misonido=NoiseModifier seed:0 scale:100.0 fractal:true roughness:1.0 iterations:10.0  strength:[-0.251,0.52,0]		addModifier copa  misonido;	addModifier copa tcopa;				numerobolas= random 5 50;				creandoBolas numerobolas 1;						-- ahora la estrella --				rad1= random 2 4;		rad2= random 1 3;		picos= random 5 9;		luminiscencia= random 1000 2000;				    extrudeision=extrude amount:1			estrella= Star radius1: rad1 radius2:rad2 position:[arbolX,arbolY,arbolZ+alto+alturacopa];			estrella.baseobject.points=picos;			     						mat =architectural();						mat.diffuseColor=( color (random 0 255) (random 0 255) (random 0 255));						mat.luminance= luminiscencia;						mat.showInViewport= true;						estrella.material=mat;										addModifier estrella extrudeision; 						rot_star= eulerangles 0 90 0;			rotate estrella rot_star			--ahora las luces-- 						numero= random 5 50;			lum= random 1000 2000;										creandoLuces numero lum;							)-- Rollouts --delete objects;rollout arbol "Generador de árbol de navidad" width:600 height:700(group "General" (	spinner posX "X: " pos:[24,32] width:64 height:16 range:[-100,100,0]; 	spinner posY "Y: " pos:[112,32] width:64 height:16 range:[-100,100,0]; 	spinner posZ "Z: " pos:[208,32] width:64 height:16 range:[-100,100,0]; 	button crearArbol "Crear árbol" pos:[300,30] width:80 height:24	button crearArbolRandom "Crear árbol random" pos:[380,30] width:100 height:24	button limpiar "Limpiar escenario" pos:[483,30] width:100 height:24				on posX changed param do(			arbolX = posX.value;		)			on posY changed param do(			arbolY=posY.value;		)			on posZ changed param do(			arbolZ=posZ.value;		)				on limpiar pressed do(			delete objects;						prematerialtronco=true;		prematerialcopa=true;		prematerialbola=true;			texturaescogida=true;					)				on crearArbol pressed do(			creado=true;											--estudiar el como limitar que no puede seleccionar las dos, que es lo uno, o lo otro-- 			if(cilindon==true) then(			crearTroncoCil posX.value posY.value posZ.value							)						else			(				crearTroncoRect posX.value posY.value posZ.value			)											crearCopa posX.value posY.value posZ.value 											)				on crearArbolRandom pressed do(						creandoArbolCualquiera();		)				)group "Tronco"(		label formatr "Forma" pos:[24,84] ;		checkbox cilin "Cilíndrico" pos:[65,95] width:90 height:16 checked:false	checkbox rect "Rectangular" pos:[200,95] width:90  height:16 checked:false		label tamañoTronco "Tamaño" pos:[24,110] width:40 height:16	spinner spinTrX "ANCHO/RADIO: " pos:[130,128] width:64 height:16 range:[0.1,50,1];	spinner spinTrZ "ALTO: " pos:[250,128] width:64 height:16 range:[0.1,50,1];		materialbutton selecMatL "Seleccionar Material" pos:[350,90] width:103 height:18		label opcion1 "ó" pos:[400,118] width:8 height:16		colorPicker colorTr "Color: " pos:[350,140] width:72 height:24 title:"Elige un color" color:[153,153,129];	checkbox randomColorT "Randomizar Color" pos:[470, 140] width:104 height:16	on spinTrX changed param do(			anchoTro=spinTrX.value;		)			on spinTrZ changed param do(			altoTro=spinTrZ.value;		)						on selecMatL picked mat do 	(		matTronco = mat		prematerialtronco=false;		texturaescogida=false;	)		on colorTr changed new_col do	(		colorTronco = new_col		prematerialtronco=false;							)		on randomColorT changed theState do(				if(randomColorT.checked) then			    coloresAleatoriosTro=true;			)			on cilin changed theState do  -- me guardo los valores en una variable global, para poder acceder desde el generador de crear árbol normal--	(		cilindon=cilin.checked;	)		on rect change theState do 	(		rectangon=rect.checked;	)		)group "Copa"(			label tamañoCopa "Tamaño" pos:[30,185] width:40 height:16	spinner spinRad "RADIO: " pos:[100,200] width:64 height:16 range:[0.1,50,1];  --a ver si puedo poner que como mínimo tenga la anchura del tronco--	spinner spinAlt "ALTURA: " pos:[225,200] width:64 height:16 range:[0.1,50,1];	materialbutton selecMatC "Seleccionar Material" pos:[350,190] width:103 height:18		label lblO "ó" pos:[400,210] width:8 height:16	colorPicker colorCopa "Color: " pos:[350,225] width:72 height:24 title:"Elige un color" color:[153,153,129];	checkbox randomColorCopa "Randomizar Color" pos:[470,225] width:104 height:16		on spinRad changed param do(		radioCopa=spinRad.value			)		on spinAlt changed param do(		altuCopa=spinAlt.value	)	on colorCopa changed new_col  do	(		colorCo= new_col		prematerialcopa=false;			)	on randomColorCopa changed theState do(				if(randomColorCopa.checked) then			    coloresAleatoriosCopa=true;		prematerialcopa=false;			)		on selecMatC picked mat do 	(		matCopa= mat		prematerialcopa=false;		texturaescogida=false;			)	)group "Accesorios"(		label grpBola "BOLAS" pos:[28,270] width:40 height:16		button crearBolinas "Crear bolas" pos:[350,270] width:60 height:24			spinner numBolas "Número de bolas:" pos:[100,290] width:100 height:16 range:[0,40,1] type:#integer		label tamañoBola "Tamaño:" pos:[44,310] width:40 height:16		spinner spinBx "RADIO: " pos:[140,310] width:64 height:16 range:[0.1,50,1];		materialbutton selecMatB "Seleccionar Material" pos:[350,300] width:103 height:18	label opcion "ó" pos:[380,320] width:8 height:16		colorPicker colorBola "Color: " pos:[350,340] width:72 height:24 title:"Elige un color" color:[153,153,129]	checkbox randomColorBola "Randomizar Color" pos:[470,300] width:100 height:16			on colorBola changed new_col  do	(		colorBo= new_col		prematerialbola=false;		coloresAleatoriosBola=false;		texturaescogida=false;			)	on randomColorBola changed theState do(				if(randomColorBola.checked) then			    coloresAleatoriosBola=true;					)			on selecMatB picked mat do 	(		matBola= mat		prematerialbola=false;		texturaescogida=true;			)			on crearBolinas pressed do(		--si da a crearBolas sin haberse creado el árbol previamente, nanai de la china, no hará nada --		if(creado) then (			creandoBolas numBolas.value spinBx.value		)								)		label grpStar "ESTRELLA" pos:[28,380] width:50 height:16		button crearStar "Crear estrella" pos:[350,400] width:100 height:24		label tamañoStar "Tamaño" pos:[44,410] width:40 height:16		spinner spinRadio1 "RADIO1: " pos:[150,410] width:64 height:16 range:[0.1,50,1];	spinner spinRadio2 "RADIO2: " pos:[150,430] width:64 height:16 range:[0.1,50,1];	spinner spinPuntas"PUNTAS: " pos:[150,450] width:64 height:16 range:[0.1,50,1];		colorPicker colorStar "Color: " pos:[350,430] width:72 height:24 title:"Elige un color" color:[153,153,129]	spinner luminis "Luminiscencia: " pos: [400,460] width:64 height: 16 range: [100,3000,100];	checkbox randomColorStar"Randomizar Color" pos:[470, 430] width:100 height:16				on spinRadio1 changed param do(				radio1star=spinRadio1.value;	)				on spinRadio2 changed param do(				radio2star=spinRadio2.value;	)		on spinPuntas changed param do(				puntas=spinPuntas.value;			)		on luminis changed param do(		luministar=luminis.value;	)		on colorStar changed new_col  do	(		colorEstre= new_col			)	on randomColorStar changed theState do(				if(randomColorStar.checked) then			    coloresAleatoriosStar=true;			)				on crearStar pressed do(		--si da a crearStar sin haberse creado el árbol previamente, nanai de la china, no hará nada --		if(creado)then(				creandoEstrella spinRadio1.value spinRadio2.value spinPuntas.value luminis.value 		)			)					label grpLight "BOMBILLITAS" pos:[28,500] width:79 height:16		button crearLights "Crear luces" pos:[350,510] width:100 height:24	spinner numeroLuz "Cantidad: " pos:[150,510] width:64 height:16 range:[0.1,50,1];	colorPicker colorLuz "Color: " pos:[108,530] width:72 height:24 title:"Elige un color" color:[153,153,129]	checkbox randomColorLuz"Randomizar Color" pos:[344,535] width:100 height:16	spinner lumi "Luminiscencia: " pos:[250,535] width:64 height:16 range:[100,3000,100];	--  las bombillas serán transparentes, osea cambiaremos la opacidad, se verán un pelinin para que parezcan de cristal				on numeroLuz changed param do(				nLuz=numeroLuz.value;	)				on colorLuz changed col_new do(				colorLight=col_new;	)		on randomColorLuz changed theState do(				if(randomColorLuz.checked) then			    coloresAleatoriosLuz=true;			)		on lumi changed param do(				luminiscencia=lumi.value;			)				on crearLights pressed do(		--si da a crearStar sin haberse creado el árbol previamente, nanai de la china, no hará nada --		if(creado)then(				creandoLuces numeroLuz.value lumi.value		)			)								label grpReg "REGALOS" pos:[24, 600] width:80 height:16				button crearRegalos "Crear regalos" pos:[350, 620] width:100 height: 16				spinner numeroReg "Cantidad: " pos:[150,620] width:64 height:20 range:[0.1,50,1];																	--  las bombillas serán transparentes, osea cambiaremos la opacidad, se verán un pelinin para que parezcan de cristal				/**/			on crearRegalos pressed do(				if(creado) then(			creandoRegalos numeroReg.value 		)	)														))		createDialog arbol